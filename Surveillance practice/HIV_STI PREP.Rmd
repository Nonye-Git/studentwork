---
title: "Senior HIV/STI Surveillance and Prevention Scientist Assessment"
author: "Chukwunonye Aneke"
date: "2024-09-30"
output: pdf_document
---

```{r setup, include=FALSE}

# Set CRAN mirror
options(repos = c(CRAN = "https://cloud.r-project.org"))

# Install modelsummary if not already installed
if (!requireNamespace("modelsummary", quietly = TRUE)) {
  install.packages("modelsummary")
}

install.packages("data.table")
install.packages("insight")
install.packages("performance")
install.packages("modelsummary")

knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(openxlsx)
install.packages("modelsummary")
install.packages("naniarExtra")
library(modelsummary)
library(naniar)
library(VIM)
library(visdat)
library(mice)
library(lme4)
library(performance)
library(see)
library(patchwork)
library(ggplot2)
library(polycor)
library(dplyr)
library(magrittr)
library(effects)
library(corrplot)
library(simputation)
install.packages("JointAI")
library(rjags)
library(JointAI)
library(missMDA)
library(knitr)
library(boot)
library(car)
library(effects)
library(tidyr)
library(ggpubr)
library(effects)
library(GGally)
library(lubridate)
library(vcd)
library(caret)
library(MASS)
 library(scales)
install.packages("pscl")
library(pscl)
 library(broom)


```

```{r}
Epidemiology_data <- read.csv("C:/Users/aneke/Downloads/Surveillance practice/Chukwunonye_covid.csv")
```

```{r}
str(Epidemiology_data)
```

Data Cleaning
```{r}
# Reformat variables

Epidemiology_data[] <- lapply(Epidemiology_data, as.factor)

str(Epidemiology_data)
```



```{r}
```


```{r}
# refort date
Epidemiology_data$admission_date <- as.Date(Epidemiology_data$admission_date, format=  "%Y/%m/%d")


Epidemiology_data$outcome_date <- as.Date(Epidemiology_data$outcome_date, format=  "%Y/%m/%d")

str(Epidemiology_data)
```



```{r}
# check the different categories of outcome

length(levels(Epidemiology_data$outcome))

levels(Epidemiology_data$outcome)
```


```{r}
# extract  patients with definite outcome ()
Definite_outcome <- Epidemiology_data %>%
  filter(outcome %in% c("Death","Discharged alive","Palliative discharge"))

Definite_outcome <- droplevels(Definite_outcome)

length(levels(Definite_outcome$outcome))

str(Definite_outcome)

```
```{r}
levels(Definite_outcome$cardiac)
```

```{r}
# Create a new column for those that have cardio vascular comorbidity or not.

Definite_outcome$cardcomorbidity <- as.factor(ifelse(Definite_outcome$cardiac == "yes", "yes", "no"))

# Creat a new column for sever outcome-Death

Definite_outcome$severeoutcome <- as.factor(ifelse(Definite_outcome$outcome == "Death", "yes", "no"))

```

Explore missing data

```{r}
sum(is.na(Definite_outcome))

```
```{r}
gg_miss_var(Definite_outcome)

vis_miss(Definite_outcome)
```
```{r}
levels(Definite_outcome$hypertension)

levels(Definite_outcome$diabetes)
```

```{r}
# Descriptive statistics

#Proportion of covid-19 diagnosis by age group, sex

Frequency_prop <- Definite_outcome %>%
  group_by(age) %>%
  summarise(count = n())%>%
            mutate(proportion= round((count/sum(count))*100,2))

#Kable
knitr::kable(Frequency_prop, caption = "Proportion table")

Frequency_prop_sex <- Definite_outcome %>%
  group_by(sex) %>%
  summarise(count = n())%>%
            mutate(proportion= round((count/sum(count))*100,2))

#Kable
knitr::kable(Frequency_prop_sex, caption = "Proportion table")

# week
#Definite_outcome$week_num <- lubridate::week(Definite_outcome$admission_date)
Definite_outcome$week_num <- strftime(Definite_outcome$admission_date, format = "%V")
Definite_outcome$week_num <- as.numeric(Definite_outcome$week_num)
Frequency_prop_week <- Definite_outcome %>%
  group_by(week_num) %>%
  summarise(count = n())

#Kable
knitr::kable(Frequency_prop_week, caption = "Proportion table for weekly diagnosis")

 #write.csv(Frequency_prop_week, "Proportion table for weekly diagnosis.csv", row.names = FALSE)

```
```{r}

# visualise
# age

Age<- ggplot(Definite_outcome, aes(x=age))+
               geom_bar(fill="steelblue", width = 0.5)+
               labs(title = "Distribution of age groups in the population",
                    x= "Age Group",
                    y= "Count")+
                    theme_minimal()

Sex<- ggplot(Definite_outcome, aes(x=sex))+
               geom_bar(fill="steelblue", width = 0.5)+
               labs(title = "Distribution of Gender in the population",
                    x= "Gender",
                    y= "Count")+
                    theme_minimal()

Week<- ggplot(Frequency_prop_week, aes(x=week_num,y= count ))+
               geom_point(colour="steelblue", size=3)+
                geom_line(colour = "steelblue")+
               labs(title = "Distribution of 6 months weekly diagnosis",
                    x= "monday",
                    y= "Number diagnosed")+
                    theme_minimal()
Age

Sex

week

```

```{r}

# Create the dataframe with your provided data
Num_wk <- c(7, 8, 11, 12, 16, 17, 20, 21, 24, 25, 29, 30)
count <- c(207, 387, 2865, 10842, 18302, 3755, 3409, 3122, 200, 2087, 44, 3)

# Create the dataframe
DF <- data.frame(Num_wk, count)

# View the dataframe
print(DF)


```

```{r}
# Create scatter plot with points and lines
Week_plot <- ggplot(DF, aes(x = Num_wk, y = count)) +
  geom_point(colour = "steelblue", size = 3) +   # Scatter plot points
  geom_line(colour = "steelblue") +              # Line connecting the points
  labs(title = "Distribution of Weekly Diagnoses",
       x = "Week",
       y = "Number Diagnosed") +
  theme_minimal()

Week_plot
```
motarlity Rate

```{r}

# number of death per week

Definite_outcome$outcome_week<- week(Definite_outcome$outcome_date)

Death_freq <- Definite_outcome %>%
  filter(outcome=="Death")%>%
  group_by(outcome_week)%>%
  summarise(count=n())

Death_freq
```
```{r}

weekly_death <- ggplot(Death_freq, aes(x=outcome_week, y= count))+
                 geom_point(color= "red", size= 3)+
                 geom_line(color ="red", size =3)+
                 labs(title = "Number of weekly death",
                      x= "Death Week",
                      y = "Number of Death")+
  theme_minimal()

weekly_death
```

```{r}
library(dplyr)

# Rename the week columns for clarity before merging
colnames(DF) <- c("week_num", "diagnosis_count")
colnames(Death_freq) <- c("week_num", "death_count")

# Merge the datasets by week_num
combined_data <- full_join(DF, Death_freq, by = "week_num")

```

```{r}
library(ggplot2)

# Plot diagnoses and deaths on the same plot
Combined_plot <- ggplot(combined_data, aes(x = week_num)) +
  geom_point(aes(y = diagnosis_count, colour = "Diagnoses"), size = 3) +  # Diagnoses points
  geom_line(aes(y = diagnosis_count, colour = "Diagnoses")) +             # Diagnoses line
  geom_point(aes(y = death_count, colour = "Deaths"), size = 3) +         # Deaths points
  geom_line(aes(y = death_count, colour = "Deaths")) +                    # Deaths line
  labs(title = "Weekly Diagnoses and Deaths",
       x = "Week",
       y = "Count") +
  scale_color_manual(values = c("Diagnoses" = "steelblue", "Deaths" = "red")) +  # Set colors
  theme_minimal()

# Print the plot
print(Combined_plot)

```

```{r}
# Check correlations among numeric variables
numeric_cols <- select_if(Definite_outcome, is.numeric)
cor_matrix <- cor(numeric_cols, use = "pairwise.complete.obs")

# Print correlation matrix
print(cor_matrix)
numeric_cols
```

```{r}

#library(ggplot2)

# Relationship between covid and cardiac conditions

cardiac <- ggplot(Definite_outcome, aes(x= cardcomorbidity))+
  geom_bar(fill="steelblue", width= 0.5)+
  labs(title= "Distribution of Covid 19 among those with cardiac condition and those without",
       x= "Presence of cardiac comorbidity",
       y= "Count")+
  theme_minimal()
cardiac

```

```{r}
Definite_outcome$diabetes<- factor(Definite_outcome$diabetes, levels = c("none",
                                                       "type I","type II","unknown"),
                                   labels = c("no","yes","yes","unknown"))

# Assuming comorbidities are in columns named like this:
comorbidity_cols <- c("renal", "cardiac", "hypertension","diabetes", "malignant_neoplasm","neurological","obesity","liver_mod_severe")

# Convert data to long format
Definite_outcome_long <- Definite_outcome %>%
  pivot_longer(cols = all_of(comorbidity_cols), names_to = "comorbidity", values_to = "present") %>%
  filter(present == "yes")  # Filter to include only rows where comorbidity is present (i.e., value is 1)

```

```{r}
# Count the number of occurrences for each comorbidity
comorbidity_count <- Definite_outcome_long %>%
  group_by(comorbidity) %>%
  summarise(count = n())

```

```{r}



# Create the bar plot for comorbidity distribution
comorbidity_plot <- ggplot(comorbidity_count, aes(x = reorder(comorbidity, count), y = count)) +
  geom_bar(stat = "identity", fill = "steelblue") +
  labs(title = "Distribution of Comorbidities Among COVID-19 Patients",
       x = "Comorbidity",
       y = "Count") +
  coord_flip() +  # Flip to make the labels readable
  theme_minimal()

# Print the plot
print(comorbidity_plot)


```
```{r}

#Create the stacked bar plot showing both outcome types
comorbidity_outcome_plot <- ggplot(Definite_outcome_long, aes(x = comorbidity, fill = outcome)) +
  geom_bar(position = "stack", width = 0.5) +
  labs(title = "Distribution of Outcomes Among COVID-19 Patients by Comorbidity",
       x = "Comorbidity",
       y = "Count") +
  coord_flip() +  # Flip the axes for readability
  theme_minimal()

# Print the plot
print(comorbidity_outcome_plot)

```

```{r}
# Summarize the counts by comorbidity and outcome
comorbidity_count <- Definite_outcome_long %>%
  group_by(comorbidity, outcome) %>%
  summarise(count = n(), .groups = "drop") %>%
  # Calculate the total count for each comorbidity
  group_by(comorbidity) %>%
  mutate(total_count = sum(count)) %>%
  ungroup() %>%
  # Arrange the comorbidities based on the total count
  arrange(desc(total_count))

# Reorder comorbidities based on total count
comorbidity_count$comorbidity <- reorder(comorbidity_count$comorbidity, comorbidity_count$total_count)

# Create the stacked bar plot with reordered comorbidities
comorbidity_outcome_plot <- ggplot(comorbidity_count, aes(x = comorbidity, y = count, fill = outcome)) +
  geom_bar(stat = "identity", position = "stack", width = 0.5) +
  labs(title = "Distribution of Outcomes Among COVID-19 Patients by Comorbidity",
       x = "Comorbidity",
       y = "Count") +
  coord_flip() +  # Flip the axes for better readability
  theme_minimal()

# Print the plot
print(comorbidity_outcome_plot)

```



```{r}
# Handling missing data

New_Definite_outcome <- Definite_outcome[, -c(1, 13:14,16,17)]

```

```{r}
# Function to impute the mode
impute_mode <- function(x) {
  mode_val <- names(which.max(table(x)))  # Find the mode
  x[is.na(x)] <- mode_val  # Replace NA values with the mode
  return(x)
}

```

```{r}
library(dplyr)

# Apply mode imputation to all columns in the dataset
New_Definite_outcome <- New_Definite_outcome %>%
  mutate(across(everything(), ~ impute_mode(.)))

```


```{r}
vis_miss(New_Definite_outcome)
```
```{r}
sum(is.na(New_Definite_outcome))
```

```{r}
# Ensure unique comorbidity levels by extracting unique comorbidities and their total counts in ascending order
unique_comorbidities <- Acomorbidity_count %>%
  distinct(Acomorbidity, total_count) %>%
  arrange(total_count) %>%
  pull(Acomorbidity)

# Reorder comorbidities based on total count (in ascending order)
Acomorbidity_count <- Acomorbidity_count %>%
  mutate(Acomorbidity = factor(Acomorbidity, levels = unique_comorbidities))

# Create the stacked bar plot with reordered comorbidities in ascending order
Acomorbidity_outcome_plot <- ggplot(Acomorbidity_count, aes(x = Acomorbidity, y = count, fill = outcome)) +
  geom_bar(stat = "identity", position = "stack", width = 0.5) +
  labs(title = "Distribution of Outcomes Among COVID-19 Patients by Comorbidity",
       x = "Comorbidity",
       y = "Count") +
  coord_flip() +  # Flip the axes for better readability
  theme_minimal()

# Print the plot
print(Acomorbidity_outcome_plot)



```

```{r}
# Assuming the imputed dataset is called 'New_Definite_outcome_imputed'

# List of comorbidities in the dataset
Acomorbidity_cols <- c("renal", "cardiac", "hypertension", "diabetes", 
                       "malignant_neoplasm", "neurological", "obesity", "liver_mod_severe")

# Filter dataset for deaths (outcome = "Death")
death_data <- New_Definite_outcome %>%
  filter(outcome == "Death")

# Calculate mortality rate for each comorbidity
mortality_rates <- New_Definite_outcome %>%
  # Pivot longer to get comorbidities in one column
  pivot_longer(cols = all_of(Acomorbidity_cols), names_to = "comorbidity", values_to = "present") %>%
  # Filter to include only rows where the comorbidity is present
  filter(present == "yes") %>%
  # Group by comorbidity and calculate total patients and deaths
  group_by(comorbidity) %>%
  summarise(
    total_patients = n(),
    deaths = sum(outcome == "Death"),
    mortality_rate = round(deaths / total_patients * 100,2)  # Mortality rate as a percentage
  ) %>%
  arrange(desc(mortality_rate))

# Display mortality rates
mortality_rates



```


```{r}
# Install the brms package if not already installed
install.packages("brms")

# Load the brms package
library(brms)

```
```{r}
# Convert to a factor with levels "No" (reference) and "Yes"
New_Definite_outcome$severeoutcome <- factor(New_Definite_outcome$severeoutcome, levels = c("No", "Yes"))
```


```{r}
# Convert 'outcome' to a factor if it isn't already
Definite_outcome$outcome <- factor(Definite_outcome$outcome, levels = c("Death", "Discharged alive", "Palliative discharge"))

# Check the levels to confirm
levels(Definite_outcome$outcome)

```

```{r}
# Load brms package
library(brms)

# Convert 'outcome' to a factor if it's not already
New_Definite_outcome$outcome <- factor(New_Definite_outcome$outcome, levels = c("Death", "Discharged alive", "Palliative discharge"))

# Check the levels again
levels(New_Definite_outcome$outcome)


```

```{r}

# Fit a generalized linear model (logistic regression) with categorical variables
model <- glm(outcome ~ age + sex + renal + hypertension + diabetes + liver_mod_severe +
             cardiac + obesity + neurological + malignant_neoplasm, 
             data = New_Definite_outcome, family = binomial())

# Check for multicollinearity using VIF
vif(model)
```


```{r}
# Split the original dataset into training and testing sets
library(caret)
set.seed(123)  # For reproducibility
train_indices <- createDataPartition(New_Definite_outcome$outcome, p = 0.7, list = FALSE)
train_data <- New_Definite_outcome[train_indices, ]
test_data <- New_Definite_outcome[-train_indices, ]
```

```{r}
library(nnet)

model_multinum <- multinom(outcome ~ age + sex + renal + hypertension + diabetes + liver_mod_severe +
                cardiac + obesity + neurological + malignant_neoplasm, 
  data = train_data[1:1000, ],  # Use a subset of the dataset
  family = multinomial(),                 # Multinomial family for multi-class outcomes
  chains = 3,                             # Number of MCMC chains
  iter = 2000,                            # Total number of iterations per chain
  warmup = 1000,                          # Number of warmup (burn-in) iterations
  thin = 1,                               # Thinning rate for MCMC samples
  seed = 123,                             # Seed for reproducibility
  cores = 2   )
```
```{r}

```



```{r}
# Summarize the model results
summary(model_multinum)


```
```{r}
step_model <- step(model_multinum, direction = "both")
```

```{r}
summary(step_model)
```
```{r}
# Extract z-values
z_values <- summary(step_model)$coefficients/summary(step_model)$standard.errors

# Compute p-values
p_values <- 2 * (1 - pnorm(abs(z_values)))

```

```{r}
coef_matrix <- coef(step_model)

OR_matrix <- exp(coef_matrix)

se_matrix <- summary(step_model)$standard.errors 
CI_lower_matrix <- exp(coef_matrix - 1.96 * se_matrix)
CI_upper_matrix <- exp(coef_matrix + 1.96 * se_matrix)

CI_lower_matrix

CI_upper_matrix

```

```{r}
# Result dataframe
library(reshape2) 

# Convert matrices into long data frames
coef_melted <- melt(coef_matrix, variable.name = "Category", value.name = "Coefficient")
pvalue_melted <- melt(p_values, variable.name = "Category", value.name = "Pvalue")
OR_melted <- melt(OR_matrix, variable.name = "Category", value.name = "OR")
CI_low_melted <- melt(CI_lower_matrix, variable.name = "Category", value.name = "CI_Low")
CI_high_melted <- melt(CI_upper_matrix, variable.name = "Category", value.name = "CI_High")

#Rename columns
coef_melted <- rename(coef_melted, Category =Var1)
pvalue_melted <- rename(pvalue_melted, Category =Var1)
OR_melted <- rename(OR_melted, Category =Var1)
CI_low_melted <- rename(CI_low_melted, Category =Var1)
CI_high_melted <- rename(CI_high_melted, Category =Var1)

# Merge all data frames
merged_df <- merge(coef_melted, pvalue_melted, by = c("Var2", "Category"))
merged_df <- merge(merged_df, OR_melted, by = c("Var2", "Category"))
merged_df <- merge(merged_df, CI_low_melted, by = c("Var2", "Category"))
final_df <- merge(merged_df, CI_high_melted, by = c("Var2", "Category"))

# Ensure the order of columns
final_df <- final_df[, c("Var2", "Category", "Pvalue", "OR", "CI_Low", "CI_High")]

# View the final data frame
print(final_df)

write.csv(final_df, file="Model Result.csv", row.names = TRUE)


```



```{r}

predicted_labels <- predict(step_model, newdata=test_data, type="class")

accuracy<- sum(predicted_labels==test_data$outcome)/length(test_data$outcome)

print(accuracy)
```
```{r}
#confusion matrix

confusionMatrix(predicted_labels,test_data$outcome)
```

RANDOM FOREST
```{r}
install.packages("randomForest")
library(randomForest)

```
```{r}
# Ensure outcome is a factor with three levels
New_Definite_outcome$outcome <- factor(New_Definite_outcome$outcome, 
                                       levels = c("Death", "Discharged alive", "Palliative discharge"))

```


```{r}
# Set seed for reproducibility
set.seed(123)

# Split the data (80% training, 20% testing)
sample_index <- sample(1:nrow(New_Definite_outcome), 0.8 * nrow(New_Definite_outcome))
train_data <- New_Definite_outcome[sample_index, ]
test_data <- New_Definite_outcome[-sample_index, ]

```

```{r}
# Train the random forest model
rf_model <- randomForest(outcome ~ age + sex + renal + hypertension + diabetes + liver_mod_severe +
                         cardiac + obesity + neurological + malignant_neoplasm,
                         data = train_data, 
                         ntree = 500,          # Number of trees
                         mtry = 3,             # Number of variables randomly sampled as candidates at each split
                         importance = TRUE)    # Calculate variable importance

# Print the model summary
print(rf_model)


```

```{r}
# Make predictions on the test set
predictions <- predict(rf_model, newdata = test_data)

# Confusion matrix to evaluate performance
confusion_matrix <- table(predictions, test_data$outcome)
print(confusion_matrix)

```

```{r}
# Calculate accuracy
accuracy <- sum(predictions == test_data$outcome) / nrow(test_data)
print(paste("Accuracy:", round(accuracy, 4)))

# You can use the caret package for more advanced performance metrics (e.g., sensitivity, specificity)
install.packages("caret")
library(caret)
confusionMatrix(predictions, test_data$outcome)

```

```{r}
# Plot variable importance
importance(rf_model)
varImpPlot(rf_model)

```



